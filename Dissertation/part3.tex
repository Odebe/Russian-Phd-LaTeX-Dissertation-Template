\chapter{Описание выбранных технологий и инструментов разработки}\label{ch:ch3}

\section{Ruby}\label{sec:ch3/sect1}
Ruby — динамический, рефлективный, интерпретируемый высокоуровневый язык программирования. Язык обладает независимой от операционной системы реализацией многопоточности, сильной динамической типизацией, сборщиком мусора и многими другими возможностями. По особенностям синтаксиса он близок к языкам Perl и Eiffel, по объектно-ориентированному подходу — к Smalltalk. Также некоторые черты языка взяты из Python, Lisp, Dylan и Клу.
Возможности и особенности:

\begin{itemize}
  \item Имеет лаконичный и простой синтаксис, частично разработанный под влиянием Ада, Eiffel и Python.
  \item Позволяет обрабатывать исключения в стиле Java и Python.
  \item Позволяет переопределять операторы, которые на самом деле являются методами.
  \item Полностью объектно-ориентированный язык программирования. Все данные в Ruby являются объектами в понимании Smalltalk. Например, число «1» — это экземпляр класса 
  \item Не поддерживает множественное наследование, но вместо него может использоваться концепция «примесей», основанная в данном языке на механизме модулей.
  \item Содержит автоматический сборщик мусора. Он работает для всех объектов Ruby, в том числе для внешних библиотек.
  \item Создавать расширения для Ruby на Си очень просто частично из-за сборщика мусора, частично из-за несложного и удобного API.
  \item Поддерживает замыкания с полной привязкой к переменным.
  \item Поддерживает блоки кода (код заключается в { … } или do … end). Блоки могут использоваться в методах или преобразовываться в замыкания.
  \item Целые переменные в Ruby автоматически конвертируются между типами Fixnum (32-разрядные) и Bignum (больше 32 разрядов) в зависимости от их значения, что позволяет 
  \item Не требует предварительного объявления переменных, но для интерпретатора желательно, чтобы переменным присваивалось пустое значение nil (тогда интерпретатор знает, что идентификатор обозначает переменную, а не имя метода).
  \item В Ruby непосредственно в языке реализованы многие шаблоны проектирования, так, например, «одиночка» (singleton) может быть (хотя и не обязан) реализован добавлением необходимых методов к одному конкретному объекту 
\end{itemize}

\section{Ruby on Rails}\label{sec:ch3/sect2}
Ruby on Rails (RoR) — фреймворк, написанный на языке программирования Ruby, реализует архитектурный шаблон Model-View-Controller для веб-приложений, а также обеспечивает их интеграцию с веб-сервером и сервером баз данных. Является открытым программным обеспечением и распространяется под лицензией MIT.
Базируется на следующих принципах разработки приложений:
\begin{itemize}
  \item максимальное использование механизмов повторного использования, позволяющих минимизировать дублирование кода в приложениях (принцип Don’t repeat yourself);
  \item по умолчанию используются соглашения по конфигурации, типичные для большинства приложений (принцип Convention over configuration) — явная спецификация конфигурации требуется только в нестандартных случаях.
\end{itemize}

Основными компонентами приложений на Ruby on Rails являются модель (англ. model), представление (англ. view) и контроллер (англ. controller). Ruby on Rails использует REST-стиль построения веб-приложений.

Модель предоставляет остальным компонентам приложения объектно-ориентированное отображение данных (таких как каталог продуктов или список заказов). Объекты модели могут осуществлять загрузку и сохранение данных в реляционной базе данных, а также реализуют бизнес-логику.

Для хранения объектов модели в реляционной СУБД по умолчанию в Rails 3 использована библиотека ActiveRecord. Конкурирующий аналог — DataMapper. Существуют плагины для работы с нереляционными базами данных, например Mongoid для работы с MongoDB.

Представление создаёт пользовательский интерфейс с использованием полученных от контроллера данных. Представление также передает запросы пользователя на манипуляцию данными в контроллер (как правило, представление не изменяет непосредственно модель).

В Ruby on Rails представление описывается при помощи шаблонов ERB — файлов HTML с дополнительными включениями фрагментов кода Ruby (Embedded Ruby, или ERb). Вывод, сгенерированный встроенным кодом Ruby, включается в текст шаблона, после чего получившаяся страница HTML возвращается пользователю. Кроме ERB возможно использовать ещё около 20 шаблонизаторов, в том числе Haml.

Контроллер в Rails — это набор логики, запускаемой после получения HTTP-запроса сервером. Контроллер отвечает за вызов методов модели и запускает формирование представления.

Соответствие интернет-адреса с действием контроллера (маршрут) задается в файле config/routes.rb.

Контроллером в Ruby on Rails является класс, наследованный от ActionController::Base для классических приложений и ActionController::API для API[3]. Открытые методы контроллера являются так называемыми действиями (англ. actions). Действия часто соответствует отдельному представлению. Например, по запросу пользователя admin/index будет вызван метод index класса AdminController и затем использовано представление index.html.erb из каталога views/admin.

\section{PostgreSQL}\label{sec:ch3/sect3}
PostgreSQL - это свободно распространяемая объектно-реляционная система управления базами данных (ORDBMS), наиболее развитая из открытых СУБД в мире и являющаяся реальной альтернативой коммерческим базам данных

\textbf{Надежность} 
Надежность PostgreSQL является проверенным и доказанным фактом и обеспечивается следующими возможностями:

полное соответствие принципам ACID - атомарность, непротиворечивость, изолированность, сохранность данных.
многоверсионность (Multiversion Concurrency Control,MVCC) используется для поддержания согласованности данных в конкурентных условиях, в то время как в традиционных базах данных используются блокировки. MVCC означает, что каждая транзакция видит копию данных (версию базы данных) на время начала транзакции, несмотря на то, что состояние базы могло уже измениться. Это защищает транзакцию от несогласованных изменений данных, которые могли быть вызваны (другой) конкурентной транзакцией, и обеспечивает изоляцию транзакций.
наличие Write Ahead Logging (WAL) - общепринятый механизм протоколирования всех транзакций, что позволяет восстановить систему после возможных сбоев.
Point in Time Recovery (PITR) - возможность восстановления базы данных (используя WAL) на любой момент в прошлом, что позволяет осуществлять непрерывное резервное копирование кластера PostgreSQL.
Репликация также повышает надежность PostgreSQL. Существует несколько систем репликации, например, Slony (тестируется версия 1.1), который является свободным и самым используемым решением, поддерживает master-slaves репликацию.
Целостность данных является сердцем PostgreSQL. Помимо MVCC, PostgreSQL поддерживает целостность данных на уровне схемы - это внешние ключи (foreign keys), ограничения (constraints).
Открытость кодов PostgreSQL означает их абсолютную доступность для любого, а либеральная BSD лицензия не накладывает никаких ограничений на использование кода.
Производительность
Производительность PostgreSQL основывается на использовании индексов, интеллектуальном планировщике запросов, тонкой системы блокировок, системе управления буферами памяти и кэширования, превосходной масштабируемости при конкурентной работе.

\textbf{Поддержка индексов} 
Стандартные индексы - B-tree, hash, R-tree, GiST (обобщенное поисковое дерево)
Частичные индексы (partial indices) - можно создавать индекс по ограниченному подмножеству значений.

Функциональные индексы (expressional indices) позволяют создавать индексы используя значения функции от параметра.
Планировщик запросов основывается на стоимости различных планов, учитывая множество факторов. Он предоставляет возможность пользователю отлаживать запросы и настраивать систему.
Система блокировок поддерживает блокировки на нижнем уровне, что позволяет сохранять высокий уровень конкурентности при защите целостности данных. Блокировка поддерживается на уровне таблиц и записей. На нижнем уровне, блокировка для общих ресурсов оптимизирована под конкретную ОС и архитектуру.
Управление буферами и кэширование используют сложные алгоритмы для поддержания эффективности использования выделенных ресурсов памяти.
Tablespaces (табличные пространства) для управления хранения данных на уровне объектов, таких как базы данных, схемы, таблицы и индексы. Это позволяет гибко использовать дисковое пространство и повышает надежность, производительность, а также способствует масштабируемости системы.
Масштабируемость основывается на описанных выше возможностях. Низкая требовательность PostgreSQL к ресурсам и гибкая система блокировок обеспечивают его шкалирование, в то время как индексы и управление буферами обеспечивают хорошую управляемость системы даже при высоких загрузках.

\textbf{Расширяемость} 
Расширяемость PostgreSQL означает, что пользователь может настраивать систему путем определения новых функций, агрегатов, типов,языков, индексов и операторов. Объектно-ориентированность PostgreSQL позволяет перенести логику приложения на уровень базы данных, что сильно упрощает разработку клиентов, так как вся бизнес логика находится в базе данных. Функции в PostgreSQL однозначно определяются названием, количеством и типами аргументов. 

\textbf{Поддержка SQL} 
Кроме основных возможностей, присущих любой SQL базе данных, PostgreSQL поддерживает:

Очень высокий уровень соответствия ANSI SQL 92, ANSI SQL 99 и ANSI SQL 2003.
Схемы, которые обеспечивают пространство имен на уровне SQL. Схемы содержат таблицы, в них можно определять типы данных, функции и операторы. Используя полное имя объекта можно одновременно работать с несколькими схемами. Схемы позволяют организовать базы данных совокупность нескольких логических частей, каждая их которых имеет свою политику доступа, типы данных.
Subqueries - подзапросы (subselects), полная поддержка SQL92. Подзапросы делают язык SQL более гибким и зачастую более эффективным.
Outer Joins - внешние связки (LEFT,RIGHT, FULL)
Rules - правила, согласно которым модифицируется исходный запрос. Главное отличие от триггеров состоит в том, что rule работает на уровне запроса и перед исполнением запроса, а триггер - это реакция системы на изменение данных, т.е. триггер запускается в процессе исполнения запроса для каждой измененной записи (PER ROW). Правила используются для указания системе, какие действия надо произвести при попытке обновления view.
Cursors - курсоры, позволяют уменьшить трафик между клиентом и сервером, а также память на клиенте, если требуется получить не весь результат запроса, а только его часть.
Table Inheritance - наследование таблиц, позволяющее создавать объекты, которые наследуют структуру родительского объекта и добавлять свои специфические атрибуты.
Stored Procedures - серверные (хранимые) процедуры позволяют реализовывать бизнес логику приложения на стороне сервера. Кроме того, они позволяют сильно уменьшить трафик между клиентом и сервером.
Триггеры позволяют управлять реакцией системы на изменение данных (INSERT,UPDATE,DELETE), как перед самой операцией (BEFORE), так и после (AFTER). Во время выполнения триггера доступны специальные переменные NEW (запись, которая будет вставлена или обновлена) и OLD (запись перед обновлением).
Cluster table - упорядочивание записей таблицы на диске согласно индексу, что иногда за счет уменьшения доступа к диску ускоряет выполнение запроса.

\textbf{Типы данных} 
PostgreSQL поддерживает большой набор встроенных типов данных:
\begin{itemize}
  \item Булев тип
  \item Численные типы
  \item Целые
  \item С фиксированной точкой
  \item С плавающей точкой
  \item Денежный тип (отличается специальным форматом вывода, а в остальном аналогичен числам с фиксированной точкой с двумя знаками после запятой)
  \item Символьные типы произвольной длины
  \item Двоичные типы
  \item Типы «дата/время» (полностью поддерживающие различные форматы, точность, форматы вывода, включая последние изменения в часовых поясах)
  \item Перечисление
  \item Типы текстового поиска
  \item Составные типы
  \item HStore (расширение, добавляющее ключ-значение в PostgreSQL)
  \item Массивы(различной длины и любого типа данных, включая текстовый и составной типы) размером до 1 Гбайта
  \item Геометрические примитивы
  \item Сетевые типы
  \item IP и IPv6-адреса
  \item CIDR-формат
  \item MAC-адрес
  \item XML-данные с поддержкой запросов XPath
  \item UUID-идентификатор
  \item JSON (начиная с версии 9.2) и более быстрый JSONB (начиная с версии 9.4)
\end{itemize}
Кроме того, пользователи могут создавать свои собственные типы данных, которые обычно можно полностью индексировать через инфраструктуру индексирования PostgreSQL - GiST, GIN, SP-GiST. К ним относятся типы данных географической информационной системы (ГИС) из проекта PostGIS для PostgreSQL.

Существует также тип данных, называемый «домен», который является таким же, как и любой другой тип данных, но с необязательными ограничениями, определенными создателем этого домена. Это означает, что любые данные, введенные в столбец с использованием домена, должны соответствовать тем ограничениям, которые были определены как часть домена.

Начиная с PostgreSQL 9.2, может использоваться тип данных, представляющий диапазон данных, которые называются типами диапазонов. Это могут быть дискретные диапазоны (например, все целые значения от 1 до 10) или непрерывные диапазоны (например, любой момент времени между 10:00 и 11:00). Доступные типы доступных диапазонов включают диапазоны целых чисел, большие целые числа, десятичные числа, отметки времени (с часовым поясом и без него) и даты.

Пользовательские типы диапазонов могут быть созданы для обеспечения доступности новых типов диапазонов, таких как диапазоны IP-адресов, с использованием типа inet в качестве базы или диапазонов с плавающей точкой, используя тип данных float в качестве базы. Типы диапазонов поддерживают включенные и исключительные границы диапазона, используя символы и () соответственно. (например, представляет все целые числа, начиная с 4 включительно, но не включая 9.) Типы диапазонов также совместимы с существующими операторами, используемыми для проверки наложения, сдерживания, права и т. д.

\textbf{Наследование} 
Таблицы могут наследовать свои характеристики от "родительской" таблицы. Данные в дочерних таблицах будут существовать в родительских таблицах, если данные не выбираются из родительской таблицы.

Наследование может быть использовано для реализации разбиения таблиц, с использованием либо триггеров либо правил, чтобы направить вставки в родительской таблице в соответствующие дочерние таблицы.

По состоянию на 2010, эта функция поддерживается не полностью, но, в частности, таблица ограничений в настоящее время не наследуемая. Все проверочные ограничения и ненулевые ограничения на родительской таблице автоматически наследуются его детьми. Другие типы ограничений (уникальные, первичный ключ, и иностранные ключевые ограничения) не наследуются.

Наследование обеспечивает способ отображения особенности иерархий обобщения, изображенных на сущность-связь диаграммах (ERD) непосредственно в базе данных PostgreSQL

Функции запроса
Операции
Полнотекстовый поиск
Просмотры
Материализованные взгляды
Обновляемые виды
Рекурсивные взгляды
Внутренний, внешний (полный, левый и правый) и крест- соединения
Суб выбирает
Коррелированные подзапросы
Регулярные выражения
Общие выражения таблиц и записываемые общие табличные выражения
Зашифрованные соединения через TLS (текущие версии не используют уязвимый SSL, даже с этой конфигурацией)
Домены
Точки сохранения
Двухфазное принятие
TOAST ( метод хранения с ограниченными возможностями ) используется для прозрачного хранения больших атрибутов таблицы (таких как большие вложения MIME или XML-сообщения) в отдельной области с автоматическим сжатием.
Встроенный SQL реализован с использованием препроцессора. Код SQL сначала записывается в C-код. Затем код запускается через препроцессор ECPG, который заменяет SQL на вызовы в библиотеку кода. Затем код может быть скомпилирован с использованием компилятора C. Встраивание работает также с C++, но не распознает все конструкции C++. [Источник 4]


\section{KVM}\label{sec:ch3/sect4}
Kernel-based Virtual Machine (KVM) – это полное решение платформенно-зависимой виртуализации для Linux на процессорах x86 с расширениями виртуализации (Intel VT или AMD-V). Для гостевых систем доступна также ограниченная поддержка паравиртуализации для Linux и Windows в форме паравиртуального сетевого драйвера.

В настоящее время KVM взаимодействует с ядром через загружаемый модуль ядра. Поддерживаются разнообразные гостевые операционные системы, такие как Linux, BSD, Solaris, Windows, Haiku, ReactOS и AROS Research Operating System. Модифицированная версия KVM (qemu) может работать на Mac OS X.

Примечание: KVM не выполняет никакой самоэмуляции; вместо этого, программа, работающая в пользовательском пространстве, применяет интерфейс /dev/kvm для настройки адресного пространства гостевого виртуального сервера, берет его смоделированные ресурсы ввода/вывода и отображает его образ на образ хоста.

В архитектуре KVM, виртуальная машина выполняется как обычный Linux-процесс, запланированный стандартным планировщиком Linux. На самом деле каждый виртуальный процессор представляется как обычный Linux-процесс. Это позволяет KVM пользоваться всеми возможностями ядра Linux.

Эмуляцией устройств управляет модифицированная версия qemu, которая обеспечивает эмуляцию BIOS, шины PCI, шины USB, а также стандартный набор устройств, таких как дисковые контроллеры IDE и SCSI, сетевые карты и т.д.

\textbf{Функциональные возможности}
\textbf{Безопасность}
Поскольку виртуальная машина реализована как Linux-процесс, она использует стандартную модель безопасности Linux для изоляции и управления ресурсами. С помощью SELinux (Security-Enhanced Linux) ядро Linux добавляет обязательные средства контроля доступа, многоуровневые и разнообразные средства защиты, а также управляет политикой безопасности. SELinux обеспечивает строгую изоляцию ресурсов и ограничивает подвижность процессов, запущенных в ядре Linux.

\textbf{Управление памятью}
KVM наследует мощные функции управления памятью от Linux. Память виртуальной машины хранится так же, как память любого другого Linux-процесса, и может заменяться, копироваться большими страницами для повышения производительности, обобщаться или сохраняться в файле на диске. Поддержка технологии NUMA (Non-Uniform Memory Access, архитектура памяти для многопроцессорных систем) позволяет виртуальным машинам эффективно обращаться к памяти большого объема.

KVM поддерживает новейшие функции виртуализации памяти от производителей процессоров, в частности, Intel Extended Page Table (EPT) и AMD Rapid Virtualization Indexing (RVI), для минимизации загрузки процессора и достижения высокой пропускной способности.

Обобщение страниц памяти поддерживается с помощью функции ядра Kernel Same-page Merging (KSM). KSM сканирует память каждой виртуальной машины, и если какие-то страницы памяти виртуальных машин идентичны, объединяет их в одну страницу, которая становится общей для этих виртуальных машин и хранится в единственной копии. Если гостевая система пытается изменить эту общую страницу, ей предоставляется собственная копия.

\textbf{Хранение данных}
KVM может использовать любой носитель, поддерживаемый Linux, для хранения образов виртуальных машин, в том числе локальные диски с интерфейсами IDE, SCSI и SATA, Network Attached Storage (NAS), включая NFS и SAMBA/CIFS, или SAN с поддержкой iSCSI и Fibre Channel. Для улучшения пропускной способности системы хранения данных и резервирования может использоваться многопоточный ввод/вывод.

Опять же, поскольку KVM входит в состав ядра Linux, может использоваться проверенная и надежная инфраструктура хранения данных с поддержкой всех ведущих производителей; его набор функций хранения проверен на многих производственных установках.

KVM поддерживает образы виртуальных машин в распределенных файловых системах, таких как Global File System (GFS2), так что они могут разделяться несколькими хостами или обобщаться с использованием логических томов. Поддержка тонкой настройки (thin provisioning) образов дисков позволяет оптимизировать использование ресурсов хранения данных, выделяя их не сразу все наперед, а только тогда, когда этого требует виртуальная машина. Собственный формат дисков для KVM ― QCOW2 ― обеспечивает поддержку снимков текущего состояния и обеспечивает несколько уровней таких снимков, а также сжатие и шифрование.

\textbf{Динамическая миграция}
KVM поддерживает динамическую миграцию, обеспечивая возможность перемещения работающих виртуальных машин между физическими узлами без прерывания обслуживания. Динамическая миграция прозрачна для пользователей: виртуальная машина остается включенной, сетевые соединения ― активными, и пользовательские приложения продолжают работать, в то время как виртуальная машина перемещается на новый физический сервер.

Кроме динамической миграции, KVM поддерживает сохранение копии текущего состояния виртуальной машины на диск, позволяя хранить ее и восстанавливать позднее.

\textbf{Драйверы устройств}
KVM поддерживает гибридную виртуализацию, когда паравиртуализированные драйверы установлены в гостевой операционной системе, что позволяет виртуальным машинам использовать оптимизированный интерфейс ввода/вывода, а не эмулируемые устройства, обеспечивая высокую производительность ввода/вывода для сетевых и блочных устройств.

Гипервизор KVM использует стандарт VirtIO, разработанный IBM и Red Hat совместно с Linux-сообществом для паравиртуализированных драйверов; это независимый от гипервизора интерфейс для создания драйверов устройств, позволяющий нескольким гипервизорам использовать один и тот же набор драйверов устройств, что улучшает взаимодействие между гостевыми системами.

Драйверы VirtIO входят в современные версии Linux-ядра (наиболее поздняя ― 2.6.25), включены в Red Hat Enterprise Linux 4.8+ и 5.3+, а также доступны для Red Hat Enterprise Linux 3. Red Hat разработала драйверы VirtIO для гостевых ОС Microsoft Windows, оптимизирующие сетевые и дисковые операции ввода/вывода; эти драйверы сертифицированы по программе сертификации Microsoft Windows Hardware Quality Labs (WHQL)

\textbf{Производительность и масштабируемость}
KVM унаследовал производительность и масштабируемость Linux, поддерживая виртуальные машины с 16 виртуальными процессорами и 256 ГБ оперативной памяти, а также хост-системы с 256 ядрами и более 1 ТБ ОЗУ. Он может обеспечить:

\begin{itemize}
  \item производительность в 95-135\% по сравнению с "голым железом" в реальных корпоративных приложениях, таких как SAP, Oracle, LAMP и Microsoft Exchange;
  \item свыше миллиона сообщений в секунду и менее чем 200-мкс задержку в виртуальных машинах, работающих на стандартном сервере;
  \item максимальные уровни консолидации более чем с 600 виртуальными машинами, выполняющими корпоративные приложения, на одном сервере.
\end{itemize}

KVM допускает виртуализацию самых требовательных рабочих нагрузок.

\section{Sidekiq}\label{sec:ch3/sect5}
Sidekiq - это фрейсворк для фоновой обработки задач, который очень полезен для обработки дорогостоящих вычислений, электронных писем и других процессов, которые лучше обслуживать вне основного веб-приложения.
Для работы с Sidekiq в приложении создаются классы "воркеры", которые описывают логику определённого процесса и экземпляры которых создаются фреймворком в отдельных потоках.
Sidekiq использует Redis для хранения очереди задач от при приложения.
  
\section{Redis}\label{sec:ch3/sect5}
Redis (Remote Dictionary Server) является быстрым opensource хранилищем ключ-значение в памяти предназначенный для использования в качестве базы данных, кэша, посредника сообщений и очереди.


Проект начался, когда Сальваторе Санфилиппо, первоначальный разработчик Redis, пытался улучшить масштабируемость своего стартапа. В результате Redis обеспечивает время отклика менее миллисекунды, обеспечивая миллионы запросов в секунду для приложений реального времени, в играх, Ad-Tech, финансовых услугах, здравоохранении и IoT.


Redis - популярный выбор для кеширования, управления сеансами, игр, списков лидеров, аналитики в реальном времени, геопространственных данных, чатов, обмена сообщениями, потоковой передачи мультимедиа и sub\\pub приложений.


Все данные Redis находятся в памяти, в отличие от баз данных, которые хранят данные на диске или SSD. Устраняя необходимость доступа к дискам, хранилища данных в памяти, такие как Redis, избегают задержек при поиске и могут получать доступ к данным в микросекундах.

Redis обладает универсальными структурами данных, высокой доступностью, геопространственными типами данных, скриптами Lua, транзакциями, постоянством на диске и поддержкой кластеров, что упрощает создание приложений для масштабирования в режиме реального времени.

\section{OpenStack}\label{sec:ch3/sect6}
OpenStack - это облачная система, которая управляет большими пулами вычислительных ресурсов, хранилищ и сетевых ресурсов в центрах обработки данных, управление к которым предоставляеется через API.

Также доступна панель мониторинга, которая позволяет администраторам контролировать пользователей и предоставлять ресурсы через веб-интерфейс.


Помимо стандартной функциональности «инфраструктура как услуга», дополнительные компоненты обеспечивают оркестровку, защиту от сбоев и управление другими сервисами для обеспечения высокой доступности пользовательских приложений.
OpenStack разбит на множество сервисов, что позволяет использовать только необходимые из них.


Список сервисов интеграция с которыми необходима:


\textbf{NOVA} - позволяет внедрять по запросу сервисы и связанные библиотеки для обеспечения масштабируемого, самообслуживаемого доступа к вычислительным ресурсам, включая <<baremetal сервера>>, виртуальным машинам и контейнерам.

\textbf{CINDER} - это сервис блочного хранилища для OpenStack. Он виртуализирует управление блочными устройствами хранения и предоставляет конечным пользователям API самообслуживания и использования этих ресурсов, не требуя каких-либо знаний о том, где хранилище фактически развернуто или на каком типе устройств. Это делается либо с помощью эталонной реализации (LVM), либо драйверов плагинов для другогих хранилищ.

\textbf{NEUTRON} - это сервис программно-конфигурируемых сетей, нацеленный на создание сетей-как-услуга (NaaS) в виртуальных вычислительных средах.

\section{KVM}\label{sec:ch3/sect7}
KVM (Kernel-based Virtual Machine) - это технология виртуализации с открытым исходным кодом, встроенная в Linux. В частности, KVM позволяет превратить Linux в гипервизор, который позволяет хост-машине запускать несколько изолированных виртуальных сред, называемых гостями или виртуальными машинами (ВМ).


KVM преобразует Linux в гипервизор 1-го типа (<<baremetal сервер>>,). Всем гипервизорам нужны компоненты уровня операционной системы - такие как диспетчер памяти, планировщик процессов, стек ввода-вывода (I / O), драйверы устройств, менеджер безопасности, сетевой стек и многое другое - для запуска виртуальных машин. KVM имеет все эти компоненты, т.к. он является частью ядра Linux. Каждая виртуальная машина реализована в виде обычного процесса Linux, запланированного стандартным планировщиком Linux, с выделенным виртуальным оборудованием, таким как сетевая карта, графический адаптер, ЦП, память и диск.


KVM является частью Linux. Linux является частью KVM. Все, что есть в Linux, есть и в KVM, но определенные особенности делают KVM предпочтительным гипервизором:

\textbf{Безопасность} - KVM использует комбинацию "Linux с расширенной безопасностью" (SELinux) и защищенной виртуализации (sVirt) для повышенной безопасности и изоляции виртуальных машин. SELinux устанавливает границы безопасности вокруг виртуальных машин. sVirt расширяет возможности SELinux, позволяя применять защиту на оснве мандатных меток (Mandatory Access Control, MAC) к гостевым виртуальным машинам и предотвращая ошибки маркировки возможные при работе вручную.


\textbf{Хранилище} - KVM может использовать любое хранилище, поддерживаемое Linux, включая локальные диски и сетевые хранилища (NAS). Многопутевой ввод / вывод может использоваться для улучшения хранения и обеспечения избыточности. KVM также поддерживает общие файловые системы, поэтому образы виртуальных машин могут совместно использоваться несколькими хостами. Образы дисков поддерживают тонкое выделение ресурсов, выделяя хранилище по требованию.


\textbf{Управление памятью} - KVM наследует функции управления памятью в Linux, включая неоднородный доступ к памяти и технологию KSM. Память виртуальной машины может быть распределена, поддержана большими томами для повышения производительности, а также может распределена в файлах на диске.


\textbf{Производительность и расширяемость} - KVM наследует производительность Linux и масштабируется в соответствии с нагрузкой при увеличении количества гостевых машин и запросов. KVM позволяет виртуализировать самые требовательные рабочие нагрузки приложений и является основой для многих корпоративных настроек виртуализации, таких как центры обработки данных и частные облака, напирмер OpenStack.


\section{Unicorn}\label{sec:ch3/sect8}
Unicorn - это сервер приложения, который позволяет Rails-приложению обрабатывать запросы параллельно. Unicorn не предназначен для прямого доступа пользователейи используется в связи с Nginx в качестве обратного прокси-сервера, который буферизует запросы и ответы между пользователями и Rails-приложением.


Unicorn использует архитектуру master/worker, где master-процесс форкает рабочие процессы и управляет ими.

\section{nginx}\label{sec:ch3/sect9}

NGINX - это ПО с открытым исходным кодом для веб-обслуживания, реверс-прокси, кеширования, балансировки нагрузки, потоковой передачи мультимедиа и многого другого. Он начинался как веб-сервер, предназначенный для максимальной производительности и стабильности. В дополнение к своим возможностям HTTP-сервера NGINX также может функционировать в качестве прокси-сервера для электронной почты (IMAP, POP3 и SMTP) и обратного прокси-сервера и балансировщика нагрузки для серверов HTTP, TCP и UDP.


NGINX изначально создавался как самый быстрый веб-сервер и поддержание этого совершенства по-прежнему является главной целью проекта. NGINX постоянно опережает Apache и другие серверы в тестах, измеряющих производительность. Однако с момента выхода первой версии NGINX веб-сайты расширились от простых HTML-страниц до динамического, многогранного содержимого. NGINX вырос вместе с ним и теперь поддерживает все компоненты современного интернета, включая WebSocket, HTTP/2 и потоковую передачу множества видеоформатов (HDS, HLS, RTMP и другие), что добавляется через использование дополнительных модулей.


NGINX также часто размещается между клиентом и вторым веб-сервером, чтобы служить терминатором SSL / TLS или веб-ускорителем. Выступая в качестве посредника, NGINX эффективно обрабатывает задачи, такие как согласование SSL / TLS или сжатие и кэширование содержимого для повышения производительности. Динамические сайты, созданные с использованием чего-либо от Node.js до PHP, обычно используют NGINX в качестве кэша содержимого и обратного прокси-сервера, чтобы снизить нагрузку на серверы приложений и максимально эффективно использовать базовое оборудование.
\section{Яндекс.Касса}\label{sec:ch3/sect10}
Яндекс.Касса — сервис онлайн-платежей для ИП, юрлиц и самозанятых. Позволяет принимать оплату, отправлять деньги клиентам и решать другие задачи, связанные с электронными платежами. Подключается к сайту, блогу или онлайн-сервису (например, к соцсети или мессенджеру).

\subsection{Способы приёма платежей}\label{sec:pay_types}
Яндекс.Касса поддерживает много способов оплаты:
\begin{itemize}
  \item Банковские карты - Visa, Masterсard, Maestro, Мир, JCB;
  \item Электронные деньги - Яндекс.Деньги, WebMoney, QIWI Wallet, WeChat Pay;
  \item Инвойсинг - Альфа-Клик, Тинькофф, Сбербанк Онлайн, B2B-платежи (Сбербанк Бизнес Онлайн);
  \item Мобильная коммерция - Мегафон, Билайн, МТС, Tele2;
\end{itemize}


\subsection{Безопасность}\label{sec:pay_security}
Сервис работает по протоколу HTTPS, который шифрует данные платежей.
Соединение между магазином и Яндекс.Кассой идет по протоколу безопасности HTTPS: данные магазина и клиентов передаются в сервис в зашифрованном виде. Информация, которая идет обратно, тоже защищена шифром.


Для использования протокола HTTPS сайту магазина необходим сертификат безопасности SSL - самоподписанный или выданный центром сертификации, так же его можно получить в личном кабинете Яндекс.Кассы при подключении.


Для работы с картами необходим сертификат соответствия PCI DSS. Это международный стандарт безопасности для платежей с карт: он включает 12 требований, которые разработаны Visa, Mastercard и другими платежными системами. Сертификат PCI DSS выдается по результатам аудиторской проверки: Яндекс.Деньги получают его каждый год.


\subsection{Выставление счетов}\label{sec:pay_accounts}
Через Яндекс.Кассу можно выставлять счета — в электронных письмах, в смс и в любых чатах (например, ВКонтакте или в Viber). Клиент сможет заплатить прямо из сообщения.

Выставлять счета можно через:
\begin{itemize}
  \item личный кабинет Кассы;
  \item Сбербанк Онлайн;  
\end{itemize}


\subsection{Выплаты клиентам}\label{sec:pay_clients}
Через Яндекс.Кассу можно отправлять деньги клиентам — всем и сразу. Это может пригодиться сервисам, которые выдают займы, делают выплаты исполнителям и выплачивают маркетинговые вознаграждения.

Деньги перечисляются:
\begin{itemize}
  \item в кошельки на Яндексе;
  \item на карты российских банков;
  \item счета в российских банках;
  \item баланс мобильных телефонов.
\end{itemize}

\subsection{Личный кабинет}\label{sec:profile}
В личном кабинете можно:

\begin{itemize}
  \item Подключить прием платежей: отправить документы, скачать договор, указать настройки для сайта (пока только для резидентов РФ).
  \item Работать с платежами: смотреть и выгружать историю операций, делать возвраты, выставлять счета клиентам по электронной почте.
  \item Работать с выплатами: смотреть и выгружать историю операций, проверять баланс выплатного шлюза.
  \item Скачивать ежемесячные акты об оказании услуг.
  \item Менять реквизиты, информацию о компании и ее представителях, а так же настройки магазинов и настройки выплат.
  \item Отправлять запросы менеджеру.
  \item Подключать дополнительные возможности Яндекс.Кассы.
  \item Добавлять новые магазины.
  \item В личном кабинете видны все включенные сервисы: магазины и выплаты клиентам.
\end{itemize}

Работать в личном кабинете могут несколько человек: владелец может добавлять пользователей и давать им разные права доступа.

